// Generated by CoffeeScript 1.7.1
(function() {
  var Xcson, coffee, findFile, fs, glob, path, stringify, traverse, _,
    __slice = [].slice;

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  glob = require('glob');

  traverse = require('traverse');

  stringify = require('json-stable-stringify');

  _ = require('lodash');

  findFile = function(paths, lookingfor) {
    var check, files;
    if (!paths) {
      paths = path.dirname(lookingfor);
    }
    if (typeof paths === 'string') {
      paths = paths.split(path.sep);
    }
    while (paths.length) {
      check = path.join.apply(this, paths.concat(["" + lookingfor + ".{xcson,cson,json}"]));
      files = glob.sync(check, {
        nonegate: true
      });
      console.log("glob", check, " = ", files);
      if (files.length) {
        return files;
      }
      paths.pop();
    }
    return false;
  };

  module.exports = Xcson = Xcson = (function() {
    var pluginregistry;

    pluginregistry = {};

    function Xcson(config) {
      var contents, context, key, postprocessors, _base, _i, _len, _ref;
      if (typeof config === 'string') {
        this.config = {
          file: config,
          dir: path.dirname(config)
        };
      } else {
        this.config = config;
      }
      this.caches = {};
      this.config.stringifySpaces = '  ';
      if ((_base = this.config).plugins == null) {
        _base.plugins = Object.keys(pluginregistry);
      }
      console.log(this.config.file);
      contents = fs.readFileSync(this.config.file).toString();
      context = {};
      _ref = this.pluginsOfType('template');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        context[key] = pluginregistry[key].fn.bind(this);
      }
      this.result = coffee["eval"](contents, {
        sandbox: context
      });
      postprocessors = this.pluginsOfType('postprocess');
      this.result = traverse(this.result).map(function() {
        var _j, _len1;
        for (_j = 0, _len1 = postprocessors.length; _j < _len1; _j++) {
          key = postprocessors[_j];
          pluginregistry[key].fn.apply(this, arguments);
        }
      });
    }

    Xcson.prototype.toObject = function() {
      return this.result;
    };

    Xcson.prototype.toString = function() {
      return stringify(this.result, {
        space: this.config.stringifySpaces
      });
    };

    Xcson.prototype["import"] = function(name) {
      var file, found, parsed;
      if (this.cache(name)) {
        return this.cache(name);
      }
      if (found = findFile(path.dirname(this.config.file), name)) {
        console.log("found:", found);
        parsed = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = found.length; _i < _len; _i++) {
            file = found[_i];
            _results.push(new Xcson(file).toObject());
          }
          return _results;
        })();
        return this.cache(name, parsed);
      } else {
        throw new Error("Xcson: can't find inheritable \"" + name + "\"");
      }
    };

    Xcson.prototype.cache = function(name, json) {
      var _ref;
      if (json) {
        this.caches[name] = json;
      }
      return (_ref = this.caches) != null ? _ref[name] : void 0;
    };

    Xcson.prototype.pluginsOfType = function(type) {
      var key, _i, _len, _ref, _results;
      _ref = this.config.plugins;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (pluginregistry[key].type === type) {
          _results.push(key);
        }
      }
      return _results;
    };

    Xcson.plugin = function(name, type, fn) {
      return pluginregistry[name] = {
        type: type,
        fn: fn
      };
    };

    return Xcson;

  })();

  Xcson.plugin('multikey', 'postprocess', function(x) {
    var key, _i, _len, _ref, _ref1;
    if ((_ref = this.key) != null ? _ref.match(/,/) : void 0) {
      _ref1 = this.key.split(/,\s*/);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key = _ref1[_i];
        this.parent.node[key] = _.cloneDeep(this.node);
      }
      return this["delete"]();
    }
  });

  Xcson.plugin('repeat', 'template', function(times, content) {
    var n, _i, _results;
    _results = [];
    for (n = _i = 1; 1 <= times ? _i <= times : _i >= times; n = 1 <= times ? ++_i : --_i) {
      _results.push(_.cloneDeep(content));
    }
    return _results;
  });

  Xcson.plugin('enumerate', 'template', function() {
    var arr, e, enumerators, _i, _len;
    enumerators = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    arr = [];
    for (_i = 0, _len = enumerators.length; _i < _len; _i++) {
      e = enumerators[_i];
      if (typeof e === "string") {
        e = this["import"].call(this, e);
      }
      arr.push.apply(arr, e);
    }
    return arr;
  });

  Xcson.plugin('inherits', 'template', function() {
    var e, extenders, key, obj, val, _i, _len;
    extenders = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    obj = {};
    for (_i = 0, _len = extenders.length; _i < _len; _i++) {
      e = extenders[_i];
      if (typeof e === "string") {
        e = _.merge.apply(this, this["import"].call(this, e));
      }
      for (key in e) {
        val = e[key];
        obj[key] = val;
      }
    }
    return obj;
  });

}).call(this);

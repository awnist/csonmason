// Generated by CoffeeScript 1.7.1
(function() {
  var CsonMason, coffee, findFile, fs, path, stringify, traverse, _,
    __slice = [].slice;

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  traverse = require('traverse');

  stringify = require('json-stable-stringify');

  _ = require('lodash');

  findFile = function(paths, lookingfor) {
    var check;
    if (!paths) {
      paths = path.dirname(lookingfor);
    }
    if (typeof paths === 'string') {
      paths = paths.split(path.sep);
    }
    while (paths.length) {
      check = path.join.apply(this, paths.concat(["" + lookingfor + ".cson"]));
      if (fs.existsSync(check)) {
        return check;
      }
      paths.pop();
    }
    return false;
  };

  module.exports = CsonMason = CsonMason = (function() {
    var pluginregistry;

    pluginregistry = {};

    function CsonMason(config) {
      var contents, context, key, postprocessors, _base, _i, _len, _ref;
      if (typeof config === 'string') {
        this.config = {
          file: config,
          dir: path.dirname(config)
        };
      } else {
        this.config = config;
      }
      this.jsons = {};
      if ((_base = this.config).plugins == null) {
        _base.plugins = Object.keys(pluginregistry);
      }
      contents = fs.readFileSync(this.config.file).toString();
      context = {};
      _ref = this.pluginsOfType('template');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        context[key] = pluginregistry[key].fn.bind(this);
      }
      this.result = coffee["eval"](contents, {
        sandbox: context
      });
      postprocessors = this.pluginsOfType('postprocess');
      this.result = traverse(this.result).map(function() {
        var _j, _len1;
        for (_j = 0, _len1 = postprocessors.length; _j < _len1; _j++) {
          key = postprocessors[_j];
          pluginregistry[key].fn.apply(this, arguments);
        }
      });
    }

    CsonMason.prototype.toObject = function() {
      return this.result;
    };

    CsonMason.prototype.toString = function() {
      return stringify(this.result);
    };

    CsonMason.prototype["import"] = function(name) {
      var found;
      if (this.json(name)) {
        return this.json(name);
      }
      console.log(path.dirname(this.config.file), name);
      if (found = findFile(path.dirname(this.config.file), name)) {
        console.log(found);
        return this.json(name, new CsonMason(found).toObject());
      } else {
        throw new Error("CsonMason: can't find inheritable \"" + name + "\"");
      }
    };

    CsonMason.prototype.json = function(name, json) {
      var _ref;
      if (json) {
        this.jsons[name] = json;
      }
      return (_ref = this.jsons) != null ? _ref[name] : void 0;
    };

    CsonMason.prototype.pluginsOfType = function(type) {
      var key, _i, _len, _ref, _results;
      _ref = this.config.plugins;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (pluginregistry[key].type === type) {
          _results.push(key);
        }
      }
      return _results;
    };

    CsonMason.plugin = function(name, type, fn) {
      return pluginregistry[name] = {
        type: type,
        fn: fn
      };
    };

    return CsonMason;

  })();

  CsonMason.plugin('multikey', 'postprocess', function(x) {
    var key, _i, _len, _ref, _ref1;
    if ((_ref = this.key) != null ? _ref.match(/,/) : void 0) {
      _ref1 = this.key.split(/,\s*/);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key = _ref1[_i];
        this.parent.node[key] = _.cloneDeep(this.node);
      }
      return this["delete"]();
    }
  });

  CsonMason.plugin('repeat', 'template', function(times, content) {
    var n, _i, _results;
    _results = [];
    for (n = _i = 1; 1 <= times ? _i <= times : _i >= times; n = 1 <= times ? ++_i : --_i) {
      _results.push(content);
    }
    return _results;
  });

  CsonMason.plugin('inherits', 'template', function() {
    var e, extenders, key, obj, val, _i, _len;
    extenders = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    obj = {};
    for (_i = 0, _len = extenders.length; _i < _len; _i++) {
      e = extenders[_i];
      if (typeof e === "string") {
        e = this["import"].call(this, e);
      }
      for (key in e) {
        val = e[key];
        obj[key] = val;
      }
    }
    return obj;
  });

}).call(this);
